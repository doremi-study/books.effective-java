# [Item1] 생성자 대신 정적 팩터리 메서드를 고려하라

### POINT
``` 
항상 생성자 대신 정적 팩터리 메서드를 사용하는 것이 아님, 사용해야 하는 상황에서만 써야함
Item1 을 제대로 이해하기 위해서 알아야 할 부분 : 열거타입, 플라이웨이트 패턴, 인터페이스의 정적 메서트, 서비스 제공자 프레임워크, 서비스 제공자 인터페이스
```

- 클래스의 인스턴스화 : public 생성자를 주로 이용.
- 클래스의 인스턴스를 반환하는 단순한 정적 메소드 : 정적 팩터리 메서드

>  Q) boxed class = wrapper class ?    
>  Wrapper Class 와 Boxing / UnBoxing   
>  Boxing: 기본 자료형의 데이터를 wrapper 클래스의 객체로 만드는 과정   
>  Un Boxing: wrapper 클래스의 데이터를 기본 자료형으로 얻어내는 과정

```java
// 정적 팩터리 메서드의 예 : 
// Boolean.Class <- boolean 기본자료형을 Boolean Wrapper Class 로 boxing 해주는 메서드
public Static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

- 정적 팩터리 메서드의 장점
    1. 이름을 가질 수 있다 (메서드 명)

       생성자는 이름을 정할 수 없을 뿐더러 동일한 매개변수 타입으로는 하나의 생성자밖에 생성할 수 없다.

    2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.

       불변클래스는 이 장점을 활용한 예이다.    
    >    🌀 **불변클래스** : 인스턴스의 내부 값을 수정 못하는 클래스 !    
       객체가 파괴될 때까지 불변 인스턴스의 정보는 변경되지 않아.    
       ex) String, Wrapper Class, BigInteger, BigDecimal

       ex) Boolean.valueOf(boolen) → 객체를 아예 생성하지 않는다.

       → 생성비용이 큰 동일 객체가 자주 요청되는 상황에서 성능을 높일 수 있다.

       → '인스턴스 통제 클래스'로 사용할 수 있다.   
    >    🌀 **인스턴스 통제 클래스**   
        * 언제 어느 인스턴스를 살아있게 할 지를 통제!   
        ⇒ 싱글턴 혹은 인스턴스화 불가로 만들 수 있다.   
        * 불변값 클래스에서 동치인 인스턴스가 단 하나뿐임을 보장한다    
        ⇒ a == b 일 때만 a.equals(b) 를 성립   
        * 플라이웨이트 패턴의 근간이 된다.   
        * 열거타입은 인스턴스가 하나만 만들어지는 것을 보장한다. 

    3. 반환타입의 하위타입 객체를 반환할 수 있는 능력이 있다.    
       
       반환할 객체의 클래스를 선택할 수 있다.   
       
       → API생성 시 정적 팩터리 매서드를 사용하면 구현클래스를 고려하지 않고 객체 반환이 가능하다 == API를 작게 유지할 수 있다    
       ⇒ “인터페이스 기반 프레임워크 생성의 핵심 기술”
    >  내부에서 어떤 동작이 일어나는지 다 알지 못하더라도 알아서 동작하는 게 많아진다는 의미

    4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

        ex) EnumSet클래스는 public 생성자 없이 정적 팩터리 메서드만 제공한다.    
        Enum의 원소의 수에 따라 EnumSet의 하위클래스의 인스턴스를 다르게 생성하는데,
        클라이언트는 팩터리가 건네주는 객체가 어느 클래스의 인스턴스인지 알 수도, 알 필요도 없다. EnumSet의 하위클래스이기만 하면 된다!

    6. 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

       ⇒ “서비스 제공자 프레임워크를 만드는 근간”

    
       🌀  **서비스 제공자 프레임워크**
        대표적인 서비스 제공자 프레임워크는 “JDBC” 가 있다.

        * 서비스 인터페이스 (구현체의 동작을 정의)
          JDBC에서 Connection
        * 제공자 등록 API (제공자가 구현체를 등록할 때 사용)    
          JDBC에서 DriverManager.registerDriver
        * 서비스 접근 API (클라이언트가 서비스의 인스턴스를 얻을 때 사용)     
          → “유연한 정적 팩터리의 실체”   : 클라이언트는 서비스 접근 API 를 사용할 때 원하는 구현체의 조건을 명시한다. 명시하지 않으면 기본구현체를 반환하거나, 지원하는 구현체를 하나씩 돌아가며 반환한다.    
          JDBC에서 DriverManager.getConnection
        * 서비스 제공자 인터페이스 (서비스 인터페이스의 인스턴스를 생성하는 팩터리 객체를 설명)  : 서비스 제공자 인터페이스가 없는 경우에는 각 구현체를 인스터스화 할 때 리플렉션을 사용해야 한다.    
          JDBC에서 Driver

       서비스 제공자 프레임워크 패턴의 변형 : 브리지 패턴, 의존 객체 주입 프레임워크, ServiceLoader(java5 이후의 범용 서비스 제공자 프레임워크) 등이 존재


- 정적 팩터리 메서드의 단점
    1. 상속을 하려면 public이나 protected 생성자가 필요하므로 정적 팩터리 메서드만 작성하면 하위 클래스 생성이 불가능하다.

       → 따라서 위에서 언급한 컬렉션 프레임워크의 유틸리티 구현 클래스는 상속 불가 !

       → 상속보다 **컴포지션(이게 뭔데?)** 을 사용하도록 유도하고 불변 타입으로 만들려면 이 제약을 지키도록 하는 역할을 한다(?)

    2. 정적 팩터리 매서드는 프로그래머가 찾기 어렵다.

    >    🌀 **정적 팩터리 메서드에 흔히 사용하는 명명 방식**    
        * from : 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드    
        * of : 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드   
        * valueOf : from 과 of 의 더 자세한 버전    
        * instance 혹은 getInstance : (매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다....?   
        * create 혹은 newInstance : instance 혹은 getInstance와 같지마, 매번 새로운 인스턴스를 생성해 반환함을 보장한다.    
        * getType : getInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다. “Type”은 팩터리 메서드가 반환할 객체의 타입이다.    
        * newType : newInstance와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다. “Type”은 팩터리 메서드가 반환할 객체의 타입이다.    
        * type : getType 과 newType의 간결한 버전
