## private 생성자나 열거 타입으로 싱글턴 임을 보증하라

###싱글턴
인스턴스를 오직 하나만 생성할 수 있는 클래스   
무상태 객체 or 설계상 유일해야 하는 시스템 컴포넌트

> ####Q ) 무상태 객체가 뭔가요?

####싱글턴의 단점
클래스가 싱글턴이면 이를 사용자를 클라이언트를 테스트하기 어려울 수 있다.   
해결방안 : 타입을 인터페이스로 정의한 다음 그 인터페이스를 구현해서 만든 싱글턴은 싱글턴 인스턴스를 가짜(mock) 구현으로 대체 가능하다.

###싱글턴을 만드는 방식
* private 생성자() & 유일한 인스턴스 접근 수단으로 public static 으로 선언된 멤버를 사용
1. pubic static 멤버로 - final 필드 사용   
   * 장점   
   1. 해당 클래스가 싱글턴임이 API에 명백히 드러남 -> public field가 final 이므로 다른 객체 참조도 불가능
   2. 간결함
2. pubic static 멤버로 - 정적 팩터리 메서드 사용
   * 장점
   1. API를 바꾸지 않고도 싱글턴이 아니게 변경 가능   
   ex) 유일한 인스턴스를 반환하던 팩터리 메서드가 호출하는 스레드 별로 다른 인스턴스를 넘겨주게 할 수 있다. -> 어떻께????
   2. 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다.
   3. 정적 팩터리의 메서드 참조를 공급자로 사용할 수 있다.    
   ex) Elvis::getInstance를 Supplier<Elvis>로 사용 - ITEM43,44
   
> 위 두 가지 방식으로 만든 싱글턴 클래스의 직렬화   
> 1_Serializable 구현   
> 2_모든 인스턴스 필드를 transient(일시적)선언
>>Java transient이란?   
>>transient는 Serialize하는 과정에 제외하고 싶은 경우 선언하는 키워드입니다.   
>>왜(Why) 필요할까요?   
>>패스워드와 같은 보안정보가 직렬화(Serialize) 과정에서 제외하고 싶은 경우에 적용합니다.
>>다양한 이유로 데이터를 전송을 하고 싶지 않을 때 선언할 수 있습니다.
> 
> 3_readResolve 메소드 제공
3. 원소가 하나인 열거타입을 선언하는 것 <- 추천😎
public static FIELD 방식과 비슷하나 여러 장점 존재.   
* 장점
1. 간결
2. 추가 노력 없이 직렬화 가능
3. 아주 복잡한 직렬화 상황이나 리플렉션 공격에서도 제 2의 인스턴스가 생기는 일 X
* 단점
1. Enum 이외의 클래스를 상속해야 하는 경우 이 방법을 사용할 수 없다. (기본적으로 열거형은 상속 불가)